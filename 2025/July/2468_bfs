#include <iostream>
#include <vector>
#include <queue>
using namespace std;

int main() {
	int n;
	cin >> n;
	
	vector<vector<int>> height(n, vector<int>(n)); // 지역의 높이 기록

  // 최고 높이
	int max = 0;
	
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			cin >> height[i][j];
			if (height[i][j] > max) max = height[i][j];
		}
	}

  // 최대 구획 수
	int maxSafeZone = 0;
  // 강우량 별로 구획 수를 구함
	for (int rain = 0; rain < max; rain++) {
		vector<vector<int>> visited(n, vector<int>(n, false));
		int safeZone = 0;
		
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				if (!visited[i][j] && height[i][j] > rain) {
          // 구획 시작
					safeZone++;
					visited[i][j] = true;

          // bfs
					queue<vector<int>> q;
					q.push({i, j});
					while (!q.empty()) {
						int x = q.front()[0];
						int y = q.front()[1];
						q.pop();

            // 상하좌우가 방문 전 & 강우량보다 높은 경우 큐에 추가, 방문 체크
						if (x - 1 >= 0 && !visited[x - 1][y] && height[x - 1][y] > rain) {
							visited[x - 1][y] = true;
							q.push({x - 1, y});
						}
						if (x + 1 < n && !visited[x + 1][y] && height[x + 1][y] > rain) {
							visited[x + 1][y] = true;
							q.push({x + 1, y});
						}
						if (y - 1 >= 0 && !visited[x][y - 1] && height[x][y - 1] > rain) {
							visited[x][y - 1] = true;
							q.push({x, y - 1});
						}
						if (y + 1 < n && !visited[x][y + 1] && height[x][y + 1] > rain) {
							visited[x][y + 1] = true;
							q.push({x, y + 1});
						}
					}
				}
			}
		}

    // 최대 구획 수 업데이트
		if (safeZone > maxSafeZone) maxSafeZone = safeZone;
	}
	
	cout << maxSafeZone;
}
